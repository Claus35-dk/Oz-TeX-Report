\subsubsection{Test Strategy}
When we started coding the server we did not have any idea about what or how we wanted to test it, which made our unstructured debugging very difficult.
Whenever an exception or error occurred, we had to use a lot of time following calls through the different layers of the server to discover where an error or exception occurred.
This was made even more difficult by our custom exceptions which mostly did not utilize error messages.
After much debugging had been done, we began to write tests to make it probable that the server performed as intended.
Overall this meant that we did not have any test strategy for the server.

A different and better approach would be if we in advance had decided which parts of the server that we had to test and which parts where redundant to test.
The level at which the tests should be made would be the next thing to decide, along with a decision about when you should write the tests (before or after the code is written).

The choice not to have any test strategy for the server was not a conscious one.
We did not consider testing until most of the code had been written and debugged.
Since we were lacking planning for the development we did not realize we had forgotten the testing.
Not testing costed us more time than had we spent the time on proper testing, since the debugging was very challenging and time consuming.

By testing the individual parts of the server, we would have caught many of the errors which turned out to be hard to find when propagated.
We would also have a much better idea of the origin of exceptions, which in turn would make debugging much easier, since we more easily would be able to identify the cause of each error based on the origin of the exception.
Using functions or types wrongly would be discovered faster if we had tested the server thoroughly, again because we would know it from the responses from the individual parts of the server.